<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ESP32 LoRa Mesh Network Interface</title>
  <link rel="stylesheet" href="/style.css"/>
</head>
<body>
  <header id="header">
    <h1>ESP32 LoRa Mesh Network Interface</h1>
    <h3>By: Ben Hastings</h3>
  </header>

  <main id="layout">
    <section class="card" id="message-card">
      <div class="card-header">
        <div>
          <h2>Send Message</h2>
          <p class="card-subtitle">Compose a broadcast, normal, or critical message.</p>
        </div>
      </div>

      <form method="POST" action="/send" class="message-form">
        <div class="form-row">
          <label for="target">Target Node</label>
          <select id="target" name="target"></select>
        </div>

        <div class="form-row">
          <label for="message">Message</label>
          <textarea id="message" name="message" placeholder="Enter Message Here..." required></textarea>
        </div>

        <div class="form-row form-row-actions">
          <input type="submit" value="Send Message"/>
        </div>
      </form>
    </section>

    <section id="chat-card" class="card tall-card">
      <div class="card-header">
        <div>
          <h2>Chat</h2>
          <p class="card-subtitle">Broadcast, normal &amp; critical messages</p>
        </div>
        <div class="card-controls">
          <label class="select-label" for="filter-peer">Conversation with</label>
          <div class="control-row inline-controls">
            <div class="select-shell">
              <select id="filter-peer">
                <option value="all" selected>Any node</option>
              </select>
            </div>
            <button id="toggle-order" type="button" class="ghost-button">Newest at bottom</button>
          </div>
        </div>
      </div>

      <div id="chat-list" class="chat-list"></div>
      <div id="chat-empty" class="empty-state">No chat messages yet.</div>
    </section>

    <section id="system-card" class="card">
      <div class="card-header">
        <div>
          <h2>System Messages</h2>
          <p class="card-subtitle">ACK, ping, maintenance &amp; command messages</p>
        </div>
      </div>

      <div class="table-wrapper fixed-height">
        <table class="info-table wide">
          <thead>
            <tr>
              <th>Time</th>
              <th>ID</th>
              <th>Type</th>
              <th>Origin</th>
              <th>Source</th>
              <th>Destination</th>
              <th>Steps</th>
              <th>Length</th>
              <th>RSSI</th>
              <th>SNR</th>
              <th>Stage</th>
              <th>Transfer</th>
              <th>Ack Status</th>
              <th>Ack For</th>
              <th>Content</th>
            </tr>
          </thead>
          <tbody id="system-tbody"></tbody>
        </table>
        <div id="system-empty" class="empty-state small">No system messages.</div>
      </div>
    </section>

    <section id="nodes-card" class="card half-card">
      <div class="card-header">
        <div>
          <h2>Nodes</h2>
          <p class="card-subtitle">Status, message counts &amp; link quality</p>
        </div>
      </div>

      <div class="table-wrapper fixed-height small-table">
        <table class="info-table">
          <thead>
            <tr>
              <th>Addr</th>
              <th>Name</th>
              <th># Msgs</th>
              <th>Avg RSSI</th>
              <th>Avg SNR</th>
              <th>Status</th>
              <th>Last Connection</th>
            </tr>
          </thead>
          <tbody id="node-tbody"></tbody>
        </table>
        <div id="node-empty" class="empty-state small">No nodes seen yet.</div>
      </div>
    </section>
  </main>

  <script>
    const POLL_MS_MESSAGES = 1000;
    const POLL_MS_NODES    = 5000;

    const CHAT_TYPES   = new Set([1, 2, 4]);
    const SYSTEM_TYPES = new Set([3, 5, 6, 7]);

    let newestID = 0;
    const allMessages = [];
    const seenMessageIds = new Set();
    let ackedIds = new Set();
    let currentNodeAddr = null;
    let chatNewestAtBottom = true;

    let selectedPeer   = 'all';
    let selectedTarget = '';

    const MSG_TYPE_LABEL = {
      1: "Broadcast",
      2: "Normal",
      3: "Ack",
      4: "Critical",
      5: "Maintenance",
      6: "Ping",
      7: "Command",
    };

    function esc(s) {
      let str = String(s ?? "");

      if (str.includes("+") || str.includes("%")) {
        const prepared = str.replace(/\+/g, "%20");
        try {
          str = decodeURIComponent(prepared);
        } catch {
          str = prepared.replace(/%([0-9A-Fa-f]{2})/g,
            (_, hh) => String.fromCharCode(parseInt(hh, 16))
          );
        }
      }

      str = str.replace(/\u2019/g, "'");

      return str
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function getTimestampSeconds(m) {
      const ts = m.timestamp;
      if (typeof ts === 'number' && Number.isFinite(ts)) {
        return ts;
      }
      if (typeof ts === 'string') {
        const d = Date.parse(ts);
        if (Number.isFinite(d)) return d / 1000;
      }
      return 0;
    }

    function formatTimeShort(tsSeconds) {
      if (!Number.isFinite(tsSeconds)) return "";
      const d = new Date(tsSeconds * 1000);
      let h = d.getHours();
      let m = d.getMinutes();
      if (h < 10) h = "0" + h;
      if (m < 10) m = "0" + m;
      return `${h}:${m}`;
    }

    function formatAgoFromEpoch(epochSeconds) {
      const nowSec = Date.now() / 1000;
      const delta = nowSec - epochSeconds;
      return formatAgo(delta);
    }

    function formatAgo(seconds) {
      const s = Math.trunc(seconds);
      const abs = Math.abs(s);

      const sec = abs % 60;
      const min = Math.floor(abs / 60) % 60;
      const hr  = Math.floor(abs / 3600) % 24;
      const day = Math.floor(abs / 86400);

      const parts = [];
      if (day) parts.push(`${day} day${day !== 1 ? 's' : ''}`);
      if (hr && parts.length < 2) parts.push(`${hr} hr${hr !== 1 ? 's' : ''}`);
      if (min && parts.length < 2) parts.push(`${min} min${min !== 1 ? 's' : ''}`);
      if (!parts.length || (sec && parts.length < 2)) parts.push(`${sec} sec${sec !== 1 ? 's' : ''}`);

      return s >= 0 ? `${parts.join(' ')} ago` : `in ${parts.join(' ')}`;
    }

    function isNum(x) { return typeof x === 'number' && Number.isFinite(x); }

    function applyPeerFilter(list) {
      if (!list.length || selectedPeer === 'all') return list;

      const peer = String(selectedPeer);

      if (!currentNodeAddr) {
        return list.filter(m =>
          String(m.origin)      === peer ||
          String(m.source)      === peer ||
          String(m.destination) === peer
        );
      }

      const me = String(currentNodeAddr);

      return list.filter(m => {
        const s = String(m.source);
        const d = String(m.destination);
        return (
          (s === me && d === peer) ||
          (s === peer && d === me)
        );
      });
    }

    function recomputeAcked() {
      const set = new Set();
      for (const m of allMessages) {
        const t = Number(m.message_type);
        if (t === 3 && m.ack_for != null && m.ack_for !== 0) {
          set.add(String(m.ack_for));
        }
      }
      ackedIds = set;
    }

    function renderChat() {
      const listEl  = document.getElementById('chat-list');
      const emptyEl = document.getElementById('chat-empty');
      if (!listEl) return;

      listEl.innerHTML = '';

      let chats = allMessages.filter(m => CHAT_TYPES.has(Number(m.message_type)));
      chats = applyPeerFilter(chats);

      if (!chats.length) {
        emptyEl.style.display = '';
        return;
      }
      emptyEl.style.display = 'none';

      chats.sort((a, b) => {
        const ta = getTimestampSeconds(a);
        const tb = getTimestampSeconds(b);
        if (ta !== tb) return chatNewestAtBottom ? ta - tb : tb - ta;
        return chatNewestAtBottom ? (a.id || 0) - (b.id || 0) : (b.id || 0) - (a.id || 0);
      });

      const frag = document.createDocumentFragment();
      const me = currentNodeAddr != null ? String(currentNodeAddr) : null;

      for (const m of chats) {
        const t       = Number(m.message_type);
        const tLabel  = MSG_TYPE_LABEL[t] || "Unknown";
        const tsSec   = getTimestampSeconds(m);
        const timeStr = formatTimeShort(tsSec);

        const origin = String(m.origin);
        const dest   = String(m.destination);

        const fromMe = me && origin === me;
        const toMe   = me && dest   === me;

        const acked = Number(m.ack_status) === 1 || ackedIds.has(String(m.id));

        const msgRow = document.createElement('div');
        msgRow.className = 'chat-row';

        const msgDiv = document.createElement('div');
        msgDiv.className = 'chat-msg';

        if (fromMe) {
          msgRow.classList.add('align-right');
          msgDiv.classList.add('from-me');
        } else {
          msgRow.classList.add('align-left');
          msgDiv.classList.add('from-them');
        }

        const meta = document.createElement('div');
        meta.className = 'chat-meta';
        meta.innerHTML =
          `<span class="pill pill-type-${t}">${esc(tLabel)}</span>` +
          `<span class="chat-route">${esc(m.source)} → ${esc(m.destination)}</span>`;
        msgDiv.appendChild(meta);

        const content = document.createElement('div');
        content.className = 'chat-content';
        content.innerHTML = esc(m.content ?? '');
        msgDiv.appendChild(content);

        const footer = document.createElement('div');
        footer.className = 'chat-footer';

        const sender = document.createElement('span');
        sender.className = 'chat-sender';
        sender.textContent = fromMe ? 'Me' : `Node ${origin}`;
        footer.appendChild(sender);

        const timeSpan = document.createElement('span');
        timeSpan.className = 'chat-timestamp';
        timeSpan.textContent = timeStr;
        footer.appendChild(timeSpan);

        if (fromMe) {
          const ackSpan = document.createElement('span');
          ackSpan.className = 'chat-ack ' + (acked ? 'chat-ack-ok' : 'chat-ack-pending');
          ackSpan.textContent = acked ? '✓' : '×';
          footer.appendChild(ackSpan);
        }

        msgDiv.appendChild(footer);
        msgRow.appendChild(msgDiv);
        frag.appendChild(msgRow);
      }

      listEl.appendChild(frag);
      listEl.scrollTop = chatNewestAtBottom ? listEl.scrollHeight : 0;
    }

    function renderSystem() {
      const tbody  = document.getElementById('system-tbody');
      const empty  = document.getElementById('system-empty');
      if (!tbody) return;

      tbody.innerHTML = '';

      let sys = allMessages.filter(m => SYSTEM_TYPES.has(Number(m.message_type)));

      if (!sys.length) {
        empty.style.display = '';
        return;
      }
      empty.style.display = 'none';

      sys.sort((a, b) => {
        const ta = getTimestampSeconds(a);
        const tb = getTimestampSeconds(b);
        if (tb !== ta) return tb - ta;
        return (b.id || 0) - (a.id || 0);
      });

      const frag = document.createDocumentFragment();
      const me = currentNodeAddr != null ? String(currentNodeAddr) : null;

      for (const m of sys) {
        const t       = Number(m.message_type);
        const tLabel  = MSG_TYPE_LABEL[t] || "Unknown";
        const tsSec   = getTimestampSeconds(m);
        const timeStr = formatTimeShort(tsSec);

        const origin = String(m.origin);
        const dest   = String(m.destination);

        const tr = document.createElement('tr');
        if (me && origin === me) {
          tr.classList.add('sys-from-me');
        } else if (me && dest === me) {
          tr.classList.add('sys-to-me');
        } else {
          tr.classList.add('sys-neutral');
        }

        tr.innerHTML =
          `<td>${esc(timeStr)}</td>` +
          `<td>${esc(m.id)}</td>` +
          `<td>${esc(tLabel)}</td>` +
          `<td>${esc(m.origin)}</td>` +
          `<td>${esc(m.source)}</td>` +
          `<td>${esc(m.destination)}</td>` +
          `<td>${esc(m.steps)}</td>` +
          `<td>${esc(m.length)}</td>` +
          `<td>${esc(m.rssi)}</td>` +
          `<td>${esc(m.snr)}</td>` +
          `<td>${esc(m.stage)}</td>` +
          `<td>${esc(m.transfer_status)}</td>` +
          `<td>${esc(m.ack_status)}</td>` +
          `<td>${esc(m.ack_for)}</td>` +
          `<td class="col-content">${esc(m.content ?? '')}</td>`;
        frag.appendChild(tr);
      }

      tbody.appendChild(frag);
    }

    function renderNodes(list) {
      const tbody      = document.getElementById('node-tbody');
      const empty      = document.getElementById('node-empty');
      const targetSel  = document.getElementById('target');
      const peerSelect = document.getElementById('filter-peer');

      if (!tbody || !targetSel || !peerSelect) return;

      tbody.innerHTML = '';
      targetSel.innerHTML = '';
      peerSelect.innerHTML = '';

      if (!Array.isArray(list) || !list.length) {
        empty.style.display = '';
      } else {
        empty.style.display = 'none';
      }

      const current = list.find(n => n.current_node === 1);
      if (current) {
        currentNodeAddr = String(current.address);
      }

      const nodeFrag = document.createDocumentFragment();
      list.sort((a, b) => a.last_connection - b.last_connection);

      for (const n of list) {
        const tr = document.createElement('tr');
        const isCurrent = n.current_node === 1;
        if (isCurrent) tr.classList.add('this-node');

        const avgRssi = isNum(n.avg_rssi) ? n.avg_rssi.toFixed(1) : esc(n.avg_rssi);
        const avgSnr  = isNum(n.avg_snr)  ? n.avg_snr.toFixed(1)  : esc(n.avg_snr);
        const lastConn = Number(n.last_connection);
        const lastStr = Number.isFinite(lastConn)
          ? formatAgoFromEpoch(lastConn)
          : esc(n.last_connection);

        let status = "ERR";
        if (n.status === 0) {
          status = "Alive";
        } else if (n.status === 1) {
          status = "Dead";
        } else {
          status = "Unknown";
        }

        tr.innerHTML =
          `<td>${esc(n.address)}</td>` +
          `<td>${esc(n.name)}</td>` +
          `<td>${esc(n.messages ?? 0)}</td>` +
          `<td>${avgRssi}</td>` +
          `<td>${avgSnr}</td>` +
          `<td>${status}</td>` +
          `<td>${lastStr}</td>`;

        nodeFrag.appendChild(tr);
      }

      tbody.appendChild(nodeFrag);

      const currentTargetValue = selectedTarget || '';

      const targetFrag = document.createDocumentFragment();
      let hasPrevTarget = false;

      const broadcastOpt = document.createElement('option');
      broadcastOpt.value = '0';
      broadcastOpt.textContent = 'Broadcast — 0';
      if (currentTargetValue && currentTargetValue === '0') {
        broadcastOpt.selected = true;
        hasPrevTarget = true;
      }
      targetFrag.appendChild(broadcastOpt);

      for (const n of list) {
        if (n.current_node === 1) continue;
        const opt = document.createElement('option');
        opt.value = String(n.address);
        opt.textContent = `${n.name ? n.name : 'Node'} — ${n.address}`;
        if (currentTargetValue && String(n.address) === String(currentTargetValue)) {
          opt.selected = true;
          hasPrevTarget = true;
        }
        targetFrag.appendChild(opt);
      }

      targetSel.appendChild(targetFrag);

      if (!hasPrevTarget && targetSel.options.length) {
        targetSel.selectedIndex = 0;
      }

      selectedTarget = targetSel.value;

      const anyOpt = document.createElement('option');
      anyOpt.value = 'all';
      anyOpt.textContent = 'Any node';
      peerSelect.appendChild(anyOpt);

      const peerFrag = document.createDocumentFragment();
      let hasPrevPeer = false;

      for (const n of list) {
        if (n.current_node === 1) continue;
        const opt = document.createElement('option');
        opt.value = String(n.address);
        opt.textContent = `${n.name ? n.name : 'Node'} — ${n.address}`;
        if (selectedPeer && String(n.address) === String(selectedPeer)) {
          opt.selected = true;
          hasPrevPeer = true;
        }
        peerFrag.appendChild(opt);
      }

      peerSelect.appendChild(peerFrag);

      if (!hasPrevPeer) {
        anyOpt.selected = true;
        selectedPeer = 'all';
      }

      renderChat();
      renderSystem();
    }

    async function pollMessages() {
      const url = newestID
        ? `/api/messages?since_id=${encodeURIComponent(newestID)}`
        : `/api/messages`;
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) return;
      const rows = await r.json();
      if (!Array.isArray(rows) || !rows.length) return;

      newestID = rows[0].id || newestID;

      for (const m of rows) {
        if (seenMessageIds.has(m.id)) continue;
        seenMessageIds.add(m.id);
        allMessages.push(m);
      }

      recomputeAcked();
      renderChat();
      renderSystem();
    }

    let nodesInFlight = false;
    let nodesRefreshQueued = false;

    async function pollNodesOnce(force = false) {
      if (nodesInFlight) {
        if (force) nodesRefreshQueued = true;
        return;
      }
      nodesInFlight = true;
      try {
        const r = await fetch('/api/nodes', { cache: 'no-store' });
        if (!r.ok) return;
        const data = await r.json();
        if (Array.isArray(data)) renderNodes(data);
      } finally {
        nodesInFlight = false;
        if (nodesRefreshQueued) {
          nodesRefreshQueued = false;
          pollNodesOnce(false);
        }
      }
    }

    let tMsg = null, tNode = null;
    function startPolling() {
      stopPolling();
      pollMessages();
      pollNodesOnce(false);
      tMsg  = setInterval(pollMessages, POLL_MS_MESSAGES);
      tNode = setInterval(() => pollNodesOnce(false), POLL_MS_NODES);
    }

    function stopPolling() {
      if (tMsg)  { clearInterval(tMsg);  tMsg  = null; }
      if (tNode) { clearInterval(tNode); tNode = null; }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stopPolling(); else startPolling();
    });

    window.addEventListener('DOMContentLoaded', () => {
      const peerSelect = document.getElementById('filter-peer');
      if (peerSelect) {
        peerSelect.addEventListener('change', (e) => {
          selectedPeer = e.target.value || 'all';
          renderChat();
        });
      }

      const targetSel = document.getElementById('target');
      if (targetSel) {
        targetSel.addEventListener('change', (e) => {
          selectedTarget = e.target.value;
        });
      }

      const toggleButton = document.getElementById('toggle-order');
      if (toggleButton) {
        toggleButton.addEventListener('click', () => {
          chatNewestAtBottom = !chatNewestAtBottom;
          toggleButton.textContent = chatNewestAtBottom ? 'Newest at bottom' : 'Newest at top';
          renderChat();
        });
      }

      startPolling();
    });
  </script>
</body>
</html>